name: Validate Server Submission

on:
  pull_request:
    paths:
      - 'servers/**'
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: read

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Setup jq
        uses: dcarbone/install-jq-action@v2

      - name: Detect changed servers
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            servers:
              - 'servers/**'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get changed server directories
        if: steps.filter.outputs.servers == 'true'
        id: changed_servers
        run: |
          # Get list of changed server/version directories
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_DIRS=$(git diff --name-only origin/${{ github.base_ref }}...${{ github.sha }} | grep '^servers/' | cut -d'/' -f1-3 | sort -u)
          else
            CHANGED_DIRS=$(git diff --name-only HEAD~1 HEAD | grep '^servers/' | cut -d'/' -f1-3 | sort -u)
          fi
          
          # Filter to only directories that exist and have index.ts
          VALID_DIRS=""
          for dir in $CHANGED_DIRS; do
            if [ -d "$dir" ] && [ -f "$dir/index.ts" ]; then
              VALID_DIRS="$VALID_DIRS $dir"
            fi
          done
          
          echo "changed_dirs=$VALID_DIRS" >> $GITHUB_OUTPUT
          echo "Changed server directories: $VALID_DIRS"

      - name: Enforce one server per PR
        if: steps.filter.outputs.servers == 'true'
        run: |
          CHANGED_DIRS="${{ steps.changed_servers.outputs.changed_dirs }}"
          COUNT=$(echo "$CHANGED_DIRS" | wc -w | tr -d ' ')
          
          if [ "$COUNT" -gt 1 ]; then
            echo "ERROR: Multiple server versions detected in this PR. Only one server+version per PR is allowed."
            echo "Changed directories: $CHANGED_DIRS"
            exit 1
          fi
          
          if [ "$COUNT" -eq 0 ]; then
            echo "No server directories changed, skipping validation"
            exit 0
          fi

      - name: Validate server structure
        if: steps.filter.outputs.servers == 'true'
        id: validation
        run: |
          CHANGED_DIRS="${{ steps.changed_servers.outputs.changed_dirs }}"
          
          if [ -z "$CHANGED_DIRS" ]; then
            echo "No server directories to validate"
            exit 0
          fi
          
          for version_dir in $CHANGED_DIRS; do
            echo "Validating $version_dir"
            
            # Extract slug and version
            SLUG=$(echo "$version_dir" | cut -d'/' -f2)
            VERSION=$(echo "$version_dir" | cut -d'/' -f3)
            
            # Check index.ts exists
            if [ ! -f "$version_dir/index.ts" ]; then
              echo "ERROR: index.ts not found in $version_dir"
              echo "validation_error=index.ts not found in $version_dir" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Check package.json exists
            if [ ! -f "$version_dir/package.json" ]; then
              echo "ERROR: package.json not found in $version_dir"
              echo "validation_error=package.json not found in $version_dir" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Version validation
            echo "Validating version $VERSION for server $SLUG"
            
            # Get all existing versions for this slug
            EXISTING_VERSIONS=$(find "servers/$SLUG" -maxdepth 1 -type d -name 'v*' 2>/dev/null | xargs -n1 basename | sort -V || echo "")
            
            # Remove current version from list if it exists (for re-submissions)
            EXISTING_VERSIONS=$(echo "$EXISTING_VERSIONS" | grep -v "^$VERSION$" || echo "")
            
            if [ -z "$EXISTING_VERSIONS" ]; then
              # First version must be v1.x.x
              if ! echo "$VERSION" | grep -qE '^v1\.[0-9]+\.[0-9]+$'; then
                echo "ERROR: First version must start with v1 (e.g., v1.0.0). Got: $VERSION"
                echo "validation_error=First version must start with v1 (e.g., v1.0.0). Got: $VERSION" >> $GITHUB_OUTPUT
                exit 1
              fi
              echo "First version validation passed: $VERSION"
            else
              # Must be higher than all existing versions
              HIGHEST_VERSION=$(echo "$EXISTING_VERSIONS" | tail -n1)
              echo "Highest existing version: $HIGHEST_VERSION"
              
              # Compare versions using sort -V
              SORTED=$(printf "%s\n%s" "$HIGHEST_VERSION" "$VERSION" | sort -V)
              HIGHEST_AFTER_SORT=$(echo "$SORTED" | tail -n1)
              
              if [ "$HIGHEST_AFTER_SORT" != "$VERSION" ] || [ "$HIGHEST_VERSION" = "$VERSION" ]; then
                echo "ERROR: Version $VERSION is not higher than existing version $HIGHEST_VERSION"
                echo "validation_error=Version $VERSION is not higher than existing version $HIGHEST_VERSION" >> $GITHUB_OUTPUT
                exit 1
              fi
              echo "Version comparison passed: $VERSION > $HIGHEST_VERSION"
            fi
            
            cd "$version_dir" && bun install
            
            # Generate wrangler.toml and entry for wrangler bundling
            echo "Bundling with wrangler..."
            echo 'export { XTRNState } from "@xtrn/server"; export { default } from "./index.ts";' > _cf_entry.ts
            VERSION_DASHED=$(echo "$VERSION" | tr '.' '-')
            WORKER_NAME="xtrn-${SLUG}-${VERSION_DASHED}"
            printf 'name = "%s"\nmain = "_cf_entry.ts"\ncompatibility_date = "2025-09-23"\ncompatibility_flags = ["nodejs_compat"]\n\n[vars]\nOAUTH_CLIENT_ID = ""\nOAUTH_CLIENT_SECRET = ""\nOAUTH_CALLBACK_URL = ""\n\n[[durable_objects.bindings]]\nname = "XTRN_STATE"\nclass_name = "XTRNState"\n\n[[migrations]]\ntag = "v1"\nnew_sqlite_classes = ["XTRNState"]\n' "$WORKER_NAME" > wrangler.toml
            
            # Dry-run deploy to validate bundling succeeds
            bunx wrangler deploy --dry-run --outdir=dist || exit 1
            
            # Smoke test with wrangler dev
            echo "Running wrangler dev smoke test..."
            bunx wrangler dev --port 18234 &
            WRANGLER_PID=$!
            
            # Poll /details up to 30 seconds
            READY=false
            for i in $(seq 1 30); do
              if curl -sf http://localhost:18234/details > /tmp/details.json 2>/dev/null; then
                READY=true
                break
              fi
              sleep 1
            done
            
            # Kill wrangler dev regardless of result
            kill $WRANGLER_PID 2>/dev/null || true
            wait $WRANGLER_PID 2>/dev/null || true
            
            if [ "$READY" != "true" ]; then
              echo "ERROR: wrangler dev smoke test failed — /details not reachable after 30s"
              echo "validation_error=Smoke test failed — wrangler dev /details unreachable" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            DETAILS_JSON=$(cat /tmp/details.json)
            echo "Smoke test passed"
            
            # Cross-validate /details response
            DETAILS_NAME=$(echo "$DETAILS_JSON" | jq -r '.name')
            DETAILS_VERSION=$(echo "$DETAILS_JSON" | jq -r '.version')
            TOOL_COUNT=$(echo "$DETAILS_JSON" | jq '.tools | length')
            
            # Strip 'v' prefix from directory version for comparison
            VERSION_NO_V="${VERSION#v}"
            
            if [ "$DETAILS_NAME" != "$SLUG" ]; then
              echo "ERROR: /details name '$DETAILS_NAME' does not match directory slug '$SLUG'"
              echo "validation_error=/details name '$DETAILS_NAME' does not match directory slug '$SLUG'" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            if [ "$DETAILS_VERSION" != "$VERSION_NO_V" ]; then
              echo "ERROR: /details version '$DETAILS_VERSION' does not match directory version '$VERSION_NO_V'"
              echo "validation_error=/details version '$DETAILS_VERSION' does not match directory version '$VERSION_NO_V'" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            echo "Cross-validation passed: name=$DETAILS_NAME, version=$DETAILS_VERSION, tools=$TOOL_COUNT"
            
            # Cross-validate package.json against /details
            PKG_NAME=$(jq -r '.name' "package.json")
            PKG_VERSION=$(jq -r '.version' "package.json")
            
            if [ "$PKG_NAME" != "$DETAILS_NAME" ]; then
              echo "ERROR: package.json name '$PKG_NAME' does not match /details name '$DETAILS_NAME'"
              echo "validation_error=package.json name '$PKG_NAME' does not match /details name '$DETAILS_NAME'" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            if [ -n "$PKG_VERSION" ] && [ "$PKG_VERSION" != "null" ] && [ "$PKG_VERSION" != "$DETAILS_VERSION" ]; then
              echo "ERROR: package.json version '$PKG_VERSION' does not match /details version '$DETAILS_VERSION'"
              echo "validation_error=package.json version '$PKG_VERSION' does not match /details version '$DETAILS_VERSION'" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            echo "Package.json cross-validation passed: name=$PKG_NAME, version=${PKG_VERSION:-not set}"
            
            # Save for PR comment and webhook
            echo "server_name=$DETAILS_NAME" >> $GITHUB_OUTPUT
            echo "server_version=$DETAILS_VERSION" >> $GITHUB_OUTPUT
            echo "tool_count=$TOOL_COUNT" >> $GITHUB_OUTPUT
            HAS_OAUTH=$(echo "$DETAILS_JSON" | jq -r 'if .oauth then "true" else "false" end')
            OAUTH_PROVIDER=$(echo "$DETAILS_JSON" | jq -r '.oauth.provider // "None"')
            echo "has_oauth=$HAS_OAUTH" >> $GITHUB_OUTPUT
            echo "oauth_provider=$OAUTH_PROVIDER" >> $GITHUB_OUTPUT
            
            rm -f _cf_entry.ts wrangler.toml
            rm -rf dist
            cd ../..
          done
          
          echo "All validations passed!"

      - name: Notify deploy-webhook
        if: success() && github.event_name == 'pull_request' && steps.validation.outputs.server_name != ''
        id: webhook
        run: |
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${{ secrets.DEPLOY_WEBHOOK_URL }}/webhook/validate" \
            -H "Authorization: Bearer ${{ secrets.WEBHOOK_SECRET }}" \
            -H "Content-Type: application/json" \
            -d '{
              "server_name": "${{ steps.validation.outputs.server_name }}",
              "server_version": "${{ steps.validation.outputs.server_version }}",
              "tool_count": "${{ steps.validation.outputs.tool_count }}",
              "has_oauth": "${{ steps.validation.outputs.has_oauth }}",
              "oauth_provider": "${{ steps.validation.outputs.oauth_provider }}",
              "pr_number": ${{ github.event.pull_request.number }},
              "repo": "${{ github.repository }}",
              "pr_url": "${{ github.event.pull_request.html_url }}"
            }')
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          echo "HTTP status: $HTTP_CODE"
          echo "Response: $BODY"
          THREAD_TS=$(echo "$BODY" | jq -r '.thread_ts // ""')
          echo "thread_ts=$THREAD_TS" >> $GITHUB_OUTPUT

      - name: Upload thread metadata
        if: success() && github.event_name == 'pull_request' && steps.validation.outputs.server_name != ''
        run: |
          mkdir -p /tmp/thread-metadata
          echo '{"thread_ts":"${{ steps.webhook.outputs.thread_ts }}","pr_number":${{ github.event.pull_request.number }}}' > /tmp/thread-metadata/thread-metadata.json
        shell: bash
      - uses: actions/upload-artifact@v4
        if: success() && github.event_name == 'pull_request' && steps.validation.outputs.server_name != ''
        with:
          name: thread-metadata-${{ github.event.pull_request.number }}
          path: /tmp/thread-metadata/thread-metadata.json
          retention-days: 1

      - name: Post success comment
        if: success() && github.event_name == 'pull_request' && steps.validation.outputs.server_name != ''
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '✅ Validation passed — pending approval'
            });

      - name: Post failure comment
        if: failure() && github.event_name == 'pull_request' && steps.validation.outputs.validation_error != ''
        uses: actions/github-script@v7
        with:
          script: |
            const error = '${{ steps.validation.outputs.validation_error }}';
            const comment = `❌ Validation failed: ${error}`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });